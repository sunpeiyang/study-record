# c++ 基础知识

## 内存

在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；

在C中，C内存区分为堆、栈、全局/静态存储区、常量存储区；

## new/delete  malloc/free 区别

* 属性：new/delete 是c++关键字， malloc/free 是库函数
* 参数：new操作符分配内存时 无需指定内存块的大小， 编译器会根据类型自动计算。malloc需要显示的指定需要内存大小
* 返回值：new返回对象类型的指针，malloc返回void\*
* 分配失败：new 会抛出bac\_alloc异常， malloc 返回NULL
* 对象： new 会先申请空间，然后调用构造函数，delete 会调用析构函数在释放空间。
* 内存区域：new 从自由存储区上分配内存空间。 malloc 从栈上分配空间

## const

#### 作用

1. 修饰变量，说明该变量为常量 不可以被改变；
2. 修饰指针，分为 指向常量的指针和指针常量；
3. 常量引用， 经常用于形式参数，既避免了拷贝，又避免了函数对值的修改
4. 修饰成员函数， 改函数内不能修改成员变量

5. ```
   int* const a = & [1]
   int const *a = & [2]
   ```

## static

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令函数重名，可以将函数定位为 static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

## 智能指针

 auto\\_ptr, shared\\_ptr, weak\\_ptr, unique  \\_ptr 其中后三个是c++11支持，并且第一个已经被c++11弃用。

##### shared\_ptr

多个智能指针可以共享同一个对象, 对象的最后一个使用者销毁对象，并清理对象有关的资源。

##### weak\_ptr

weak\_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak\\_ptr 都会自动成空 （ empty）。因此，在 default 和 copy 构造函数之外，weak\\_ptr 只提供 “接受一个 shared\\_ptr” 的构造函数。

可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

##### uniq\_ptr

unique\_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

##### auto\_ptr

c++11被弃用。由uniq\\_ptr 替代

```
template<typename T>
void bad_print(auto_ptr<T> p)
{
    if (p.get() == NULL)
        cout << "null";
    else
        cout << *p;
} //函数结束后会将p释放， 出错。
```

## 迭代器失效

#### 1、vector

#### 删除一个元素后，迭代器位置指向下一个元素地址。正确写法：

```
 for (auto it = a.begin(); it != a.end();)
 {
        if ((*it) == 5){
            it=a.erase(it); //返回下一位置
        }
        else
            ++it;    
}
```

#### 2、map

```
{
    if（*it == 5）
    {
        a.erase(it++); //it在释放前右移   实际上先执行的是it++, 不过， it++的返回值是原来的it
    }
    else
        it++;
}
```

#### 3、list

资料显示list不存在迭代器失效问题，可测试时会出现问题，解决方案同map。

## 虚函数列表

虚函数表中只存有一个虚函数的指针地址，不存放普通函数或是构造函数的指针地址。只要有虚函数，C++类都会存在这样的一张虚函数表，不管是普通虚函数  亦或 是 纯虚函数，亦或是 派生类中隐式声明的这些虚函数都会 生成这张虚函数表。

